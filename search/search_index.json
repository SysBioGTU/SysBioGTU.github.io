{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Computational Systems Biology Group - GTU To learn more about our research group, please visit Computational Systems Biology website . Here, we provide tutorials on Flux Balance Analysis (FBA) of small scale metabolic networks from literature, both in MATLAB and R. A tutorial on FBA A tutorial on FVA Simulation of Corynebacterium glutamicum metabolic network from Vallino and Stephanopoulos (1993)","title":"Home"},{"location":"#welcome-to-computational-systems-biology-group-gtu","text":"To learn more about our research group, please visit Computational Systems Biology website . Here, we provide tutorials on Flux Balance Analysis (FBA) of small scale metabolic networks from literature, both in MATLAB and R. A tutorial on FBA A tutorial on FVA Simulation of Corynebacterium glutamicum metabolic network from Vallino and Stephanopoulos (1993)","title":"Welcome to Computational Systems Biology Group - GTU"},{"location":"fbaIMPLEMENT/","text":"CONTRIBUTORS: Written: Regan ODONGO , Edited: Tunahan \u00c7AKIR FBA Implementation Steps Define the system\u2019s boundary (e.g. cell wall). Make ready the reaction list, which makes up the metabolic network. The reactions should be divided into two groups as follows: Internal reactions i.e. reactions confined within the system\u2019s boundary. These should be written as well-balanced equations based on their reaction stoichiometries, with reactants on the left-hand side and products on the right-hand side. Exchange reactions i.e. reactions for metabolites taken up or released outside the system\u2019s boundary From the figure above, for metabolites, mA , entering the system, the reaction is written as: \\to m_A i.e. metabolite A is introduced into the system from outside the system\u2019s boundary (an uptake reaction ). On the other hand, for metabolites leaving the system, mB and mC , the reaction is written as: \\to m_B \\to m_C i.e. metabolite B and C are secreted out of the system. For the system defined in the figure above, the set of reactions in the system can be written as: \\begin{align} \\to m_A \\qquad... \\qquad{R_1}\\\\ {m_A} {\\leftrightarrow} {m_B} \\qquad... \\qquad{R_2}\\\\ {m_A} \\leftrightarrow {m_C} \\qquad... \\qquad{R_3}\\\\ {m_B} \\rightarrow \\qquad... \\qquad{R_4}\\\\ {m_C} \\rightarrow \\qquad... \\qquad{R_5} \\end{align} Write differential mass balances around intracellular metabolites. For each intracellular metabolite, its amount within the system boundary (within the cell) will be increased by the reactions that produce it while the corresponding amount/pool will be consumed up by the reactions that use it as a substrate. That is, the intracellular metabolite concentrations over time will change as a function of the reaction rates that consume or produce them. This can be represented as a series of differential mass balances around intracellular metabolites as shown below: \\begin{align} \\frac{dm_A}{dt} &= R_1 - R_2 - R_3 \\\\ \\frac{dm_B}{dt} &= R_2 - R_4\\\\ \\frac{dm_C}{dt} &= R_3 - R_5 \\end{align} The major assumption made by FBA is steady-state assumption. That is, there won\u2019t be any net accumulation of intracellular metabolites over sufficiently long time. Under this assumption, the right-hand side of the equations above will be zero, leading to a system of linear equations to be solved for the prediction of metabolic fluxes (reaction rates). \\begin{align} R_1 - R_2 - R_3 &= 0 \\\\ R_2 - R_4 &= 0\\\\ R_3 - R_5 &= 0 \\end{align} Represent the set of equations derived from mass balances in matrix format. The system of linear equations derived above can be represented in matrix format as given below. \\begin{align} S.v &= b \\end{align} \\left\\{ \\begin{array}{c} {S_{11}}{v_1} + {S_{12}}{v_2} + ... {S_{1n}}{v_n} = 0 \\\\ {S_{21}}{v_1} + {S_{22}}{v_2} + ... {S_{2n}}{v_n} = 0 \\\\ ........... \\\\ {S_{m1}}{v_1} + {S_{m2}}{v_2} + ... {S_{mn}}{v_n} = 0 \\end{array} \\right. and for the example given previously, \\begin{align} R_1 - R_2 - R_3 &= 0 \\\\ R_2 - R_4 &= 0\\\\ R_3 - R_5 &= 0 \\end{align} The coefficients of unknowns in those equations indeed correspond to the stoichiometric coefficients of metabolites in the reaction list. Create a right-hand side zero vector (b) . Its dimension must be m\u00d71 \\begin{align} b &= \\left( 0 \\qquad0 \\qquad0\\right) \\end{align} for each of the mass balance equations \\frac{dm_A}{dt} \\frac{dm_B}{dt} \\frac{dm_C}{dt} Construct the stoichiometric matrix (e.g. in Excel). In this matrix, the rows represent the metabolites while the columns represent the reactions. For a system with m metabolites and n reactions, the resultant stoichiometric/coefficient matrix will have an m\u00d7n dimension. Care should be taken to ensure that the coefficient values are correctly defined to avoid errors in subsequent steps. For every reaction, the stoichiometric coefficient values of metabolites produced by the reaction are declared with positive values while those for metabolites consumed by the reaction are declared with negative values. All other metabolites are assigned with zero values for that reaction (column) in the stoichiometric matrix. Following is an example of a stoichiometric matrix derived from the system of linear equations defined in the previous step: For convenience, such small networks, after defining in Excel worksheet, can be saved as a MATLAB object in a .mat file object format. An alternative is to use R, which we describe later. In MATLAB, this can be done as follows: - Load the Excel file using stoichMat = xlsread(\u2018filename.xlsx\u2019), assuming the file is named as \u2018filename.xlsx\u2019. - Next, use save(\u2018stoichMat.mat\u2019,\u2019 stoichMat\u2019,\u2019mat\u2019) to save the matrix as a .mat file object. Note that should the input file be large, other options in the \u2018save\u2019 function would be needed. - This .mat file can be introduced into the working space memory of MATLAB using the \u2018load\u2019 function, e.g.load(\u2018stoichMat.mat\u2019). Define the other system constraints: Three main constraints are defined : mass-balance based stoichiometric constraints, reversibility constraints and measurement constraints: Stoichiometric constraint : already defined using the stoichiometric matrix as explained above. Care must be taken as numerical problems may be experienced should the stoichiometric matrix be wrongly defined. Reversibility constraints : Here, two vectors, lower-bound vector and upper-bound vector are constructed to define the lower and upper bounds of the rates of reactions in the system based on reaction irreversibility. If the system has n reactions, the dimensions of the resulting vectors will be n\u00d71. Based on reaction irreversibility, for a reversible reaction, R~i, lb~i=-Infinity while the ub_i=+Infinity. On the other hand, if the reaction is an irreversible reaction, then, lb_i=0 while the ub_i=+Infinity. It is always better to use large values such as 1,000 in place of infinity. Measurement Constraints : If a measured physiological flux rate is available, the index of the corresponding reaction(s) in the ub and lb vectors should be defined using this value. For instance, if R_1is measured as 3 mmol/gram dry weight/hr, the ub and lb will be defined as follows: \\begin{array}{c|lcr} & {V_1} & {V_2} & {V_3}& {V_4}& {V_5} \\\\ \\hline {m_A} & 1 & -1& -1 & 0 & 0 \\\\ {m_B} & 0 & 1& 0 & -1 & 0 \\\\ {m_C} & 0 & 0& 1 & 0 & -1 \\end{array} Optimize the system based on the defined constraints . The example defined above is a typical linear system of equations that can be solved by most optimization programs. The MATLAB\u2019s optimization toolbox has a base linprog function for handling such linear programming problems. This function, however, is less robust for the case of more complex models (e.g. those with over 30 reactions). Instead, GLPK solver can be used for such models. This is a free linear programming solver with a MATLAB interface. To install it in MATLAB, download the latest version form this link: http://sourceforge.net/projects/glpkmex/files/glpkmex/2.11/. Unzip the file into a folder and add the folder to the MATLAB\u2019s current path by following File -> SetPath in the MATLAB menu bar and browsing to find right folder. A rather much stable solver is Gurobi that can be found here: https://www.gurobi.com/downloads/gurobi-optimizer-eula/. A free 3-month academic license can be obtained by signing up using your institutional (university given) e-mail address in this link: https://www.gurobi.com/academia/academic-program-and-licenses/. As compared to other solvers, Gurobi is much easier to use as shown below. Please see how this can be done in MATLAB and R","title":"Procedure for creating a metabolic model for FBA"},{"location":"fbaIMPLEMENT/#fba-implementation-steps","text":"Define the system\u2019s boundary (e.g. cell wall). Make ready the reaction list, which makes up the metabolic network. The reactions should be divided into two groups as follows: Internal reactions i.e. reactions confined within the system\u2019s boundary. These should be written as well-balanced equations based on their reaction stoichiometries, with reactants on the left-hand side and products on the right-hand side. Exchange reactions i.e. reactions for metabolites taken up or released outside the system\u2019s boundary From the figure above, for metabolites, mA , entering the system, the reaction is written as: \\to m_A i.e. metabolite A is introduced into the system from outside the system\u2019s boundary (an uptake reaction ). On the other hand, for metabolites leaving the system, mB and mC , the reaction is written as: \\to m_B \\to m_C i.e. metabolite B and C are secreted out of the system. For the system defined in the figure above, the set of reactions in the system can be written as: \\begin{align} \\to m_A \\qquad... \\qquad{R_1}\\\\ {m_A} {\\leftrightarrow} {m_B} \\qquad... \\qquad{R_2}\\\\ {m_A} \\leftrightarrow {m_C} \\qquad... \\qquad{R_3}\\\\ {m_B} \\rightarrow \\qquad... \\qquad{R_4}\\\\ {m_C} \\rightarrow \\qquad... \\qquad{R_5} \\end{align} Write differential mass balances around intracellular metabolites. For each intracellular metabolite, its amount within the system boundary (within the cell) will be increased by the reactions that produce it while the corresponding amount/pool will be consumed up by the reactions that use it as a substrate. That is, the intracellular metabolite concentrations over time will change as a function of the reaction rates that consume or produce them. This can be represented as a series of differential mass balances around intracellular metabolites as shown below: \\begin{align} \\frac{dm_A}{dt} &= R_1 - R_2 - R_3 \\\\ \\frac{dm_B}{dt} &= R_2 - R_4\\\\ \\frac{dm_C}{dt} &= R_3 - R_5 \\end{align} The major assumption made by FBA is steady-state assumption. That is, there won\u2019t be any net accumulation of intracellular metabolites over sufficiently long time. Under this assumption, the right-hand side of the equations above will be zero, leading to a system of linear equations to be solved for the prediction of metabolic fluxes (reaction rates). \\begin{align} R_1 - R_2 - R_3 &= 0 \\\\ R_2 - R_4 &= 0\\\\ R_3 - R_5 &= 0 \\end{align} Represent the set of equations derived from mass balances in matrix format. The system of linear equations derived above can be represented in matrix format as given below. \\begin{align} S.v &= b \\end{align} \\left\\{ \\begin{array}{c} {S_{11}}{v_1} + {S_{12}}{v_2} + ... {S_{1n}}{v_n} = 0 \\\\ {S_{21}}{v_1} + {S_{22}}{v_2} + ... {S_{2n}}{v_n} = 0 \\\\ ........... \\\\ {S_{m1}}{v_1} + {S_{m2}}{v_2} + ... {S_{mn}}{v_n} = 0 \\end{array} \\right. and for the example given previously, \\begin{align} R_1 - R_2 - R_3 &= 0 \\\\ R_2 - R_4 &= 0\\\\ R_3 - R_5 &= 0 \\end{align} The coefficients of unknowns in those equations indeed correspond to the stoichiometric coefficients of metabolites in the reaction list. Create a right-hand side zero vector (b) . Its dimension must be m\u00d71 \\begin{align} b &= \\left( 0 \\qquad0 \\qquad0\\right) \\end{align} for each of the mass balance equations \\frac{dm_A}{dt} \\frac{dm_B}{dt} \\frac{dm_C}{dt} Construct the stoichiometric matrix (e.g. in Excel). In this matrix, the rows represent the metabolites while the columns represent the reactions. For a system with m metabolites and n reactions, the resultant stoichiometric/coefficient matrix will have an m\u00d7n dimension. Care should be taken to ensure that the coefficient values are correctly defined to avoid errors in subsequent steps. For every reaction, the stoichiometric coefficient values of metabolites produced by the reaction are declared with positive values while those for metabolites consumed by the reaction are declared with negative values. All other metabolites are assigned with zero values for that reaction (column) in the stoichiometric matrix. Following is an example of a stoichiometric matrix derived from the system of linear equations defined in the previous step: For convenience, such small networks, after defining in Excel worksheet, can be saved as a MATLAB object in a .mat file object format. An alternative is to use R, which we describe later. In MATLAB, this can be done as follows: - Load the Excel file using stoichMat = xlsread(\u2018filename.xlsx\u2019), assuming the file is named as \u2018filename.xlsx\u2019. - Next, use save(\u2018stoichMat.mat\u2019,\u2019 stoichMat\u2019,\u2019mat\u2019) to save the matrix as a .mat file object. Note that should the input file be large, other options in the \u2018save\u2019 function would be needed. - This .mat file can be introduced into the working space memory of MATLAB using the \u2018load\u2019 function, e.g.load(\u2018stoichMat.mat\u2019). Define the other system constraints: Three main constraints are defined : mass-balance based stoichiometric constraints, reversibility constraints and measurement constraints: Stoichiometric constraint : already defined using the stoichiometric matrix as explained above. Care must be taken as numerical problems may be experienced should the stoichiometric matrix be wrongly defined. Reversibility constraints : Here, two vectors, lower-bound vector and upper-bound vector are constructed to define the lower and upper bounds of the rates of reactions in the system based on reaction irreversibility. If the system has n reactions, the dimensions of the resulting vectors will be n\u00d71. Based on reaction irreversibility, for a reversible reaction, R~i, lb~i=-Infinity while the ub_i=+Infinity. On the other hand, if the reaction is an irreversible reaction, then, lb_i=0 while the ub_i=+Infinity. It is always better to use large values such as 1,000 in place of infinity. Measurement Constraints : If a measured physiological flux rate is available, the index of the corresponding reaction(s) in the ub and lb vectors should be defined using this value. For instance, if R_1is measured as 3 mmol/gram dry weight/hr, the ub and lb will be defined as follows: \\begin{array}{c|lcr} & {V_1} & {V_2} & {V_3}& {V_4}& {V_5} \\\\ \\hline {m_A} & 1 & -1& -1 & 0 & 0 \\\\ {m_B} & 0 & 1& 0 & -1 & 0 \\\\ {m_C} & 0 & 0& 1 & 0 & -1 \\end{array} Optimize the system based on the defined constraints . The example defined above is a typical linear system of equations that can be solved by most optimization programs. The MATLAB\u2019s optimization toolbox has a base linprog function for handling such linear programming problems. This function, however, is less robust for the case of more complex models (e.g. those with over 30 reactions). Instead, GLPK solver can be used for such models. This is a free linear programming solver with a MATLAB interface. To install it in MATLAB, download the latest version form this link: http://sourceforge.net/projects/glpkmex/files/glpkmex/2.11/. Unzip the file into a folder and add the folder to the MATLAB\u2019s current path by following File -> SetPath in the MATLAB menu bar and browsing to find right folder. A rather much stable solver is Gurobi that can be found here: https://www.gurobi.com/downloads/gurobi-optimizer-eula/. A free 3-month academic license can be obtained by signing up using your institutional (university given) e-mail address in this link: https://www.gurobi.com/academia/academic-program-and-licenses/. As compared to other solvers, Gurobi is much easier to use as shown below. Please see how this can be done in MATLAB and R","title":"FBA Implementation Steps"},{"location":"fbaINTRO/","text":"CONTRIBUTORS: Written: Regan ODONGO , Edited: Tunahan \u00c7AKIR Why FBA? Biological systems are composed mainly of cells, whose major components are biomolecules such as metabolites, enzymes, and other types of proteins. These components are encapsulated within a bounded system, and act as a unit through several types of physicochemical interactions to achieve the tasks that are required to keep cells alive. To this aim, metabolites are synthesised or broken down through enzymatic interconversions to maintain a constant internal environment (homeostasis). Because of their strong interdependence, changing the rate of conversion of one metabolite to another in the system leads to changes in the rates of enzymatic conversions, termed reactions. Thus, this metabolite interdependent system can be thought of as a network whose nodes are metabolites and edges are reactions. To gain a full understanding of such systems, it is essential to study them as a single unit whose different parts work together to achieve the same goal. Flux balance analysis (FBA) is a mathematical approach for predicting rates of reactions, termed fluxes, in a metabolic network to estimate the phenotypic state of a cell (Orth et al., 2010; Rajvanshi & Venkatesh, 2013). It is a holistic approach that can be used to study biological systems at genome scale. In this context, the goal of FBA is to estimate the fluxes through each metabolic reaction in the biological system and, hence, allow for the prediction of systemic metabolic flux changes following a change in the system\u2019s surrounding environment. Although it is subject to some assumptions (see below), predictions from FBA have been shown to mirror real physiological values under controlled experimental conditions with living biological systems. FBA approach is based on three major pillars: (i) differential mass balances written around intracellular metabolites in the biological system at steady state, (ii) constraints on reaction rates based on reaction reversibility and experimental measurements, (iii) a biologically relevant objective function to solve for mass balance derived underdetermined set of equations subject to constraints. The main advantage here is that FBA only requires reaction stoichiometry and reaction reversibility information, without requiring the difficult-to-measure enzyme kinetics of the enzyme-catalysed reactions (Orth et al., 2010). This tutorial provides a step-by-step description of the implementation of FBA for metabolic networks using a toy model. References Orth, J. D., Thiele, I., & Palsson, B. O. (2010). What is flux balance analysis? In Nature Biotechnology (Vol. 28, Issue 3, pp. 245\u2013248). Rajvanshi, M., & Venkatesh, K. V. (2013). Flux Balance Analysis. In Encyclopedia of Systems Biology (pp. 749\u2013752).","title":"Introduction to Flux Balance Analysis"},{"location":"fbaMATLAB/","text":"CONTRIBUTORS: Written: Regan ODONGO , Edited: Tunahan \u00c7AKIR Procedure for using Gurobi solver in MATLAB for FBA Gurobi solver can used to solve most programming problems. In the linear system we defined above, we seek to solve the following problem: min/max \\sum_{i=0}^n f(v_i), such that S\u00d7v \\leq b, Seq\u00d7v = beq, lb \\leq v \\leq ub. The output of this optimization problem is the vector v, which optimizes the function f. The general implementation steps are as follows: sol=gurobi(model). Here, the object \u2018model\u2019 is a MATLAB structure object with the following main fields: model.A \u2192 An mxn matrix. the S matrix (stoichiometric matrix) must be renamed as model.A and stored as a sparse matrix. Using sparse(S) returns a sparse matrix for the S matrix. model.obj \u2192 An nx1 vector. The objective function vector, f, explained above must be renamed as model.obj. model.lb \u2192 An nx1 vector. The lower bound vector. model.ub \u2192 An nx1 vector. The upper bound vector. model.rhs \u2192 A zero m\u00d71 vector. The right-hand-side vector, b, explained above must be renamed as model.rhs. model.vtype \u2192 An nx1 vector. It is a cell array that can be of \u2018B\u2019, \u2018C\u2019 or \u2018I\u2019 for binary, continuous and integer respectively based on the problem being solved. In FBA, all the unknowns (rates) are continuous. Therefore, all elements of model.vtype is set to \u2018C\u2019. model.sense \u2192 An mx1 vector. It is a cell array that can be of \u2018=\u2019, \u2018<\u2019 or \u2018>\u2019 for equality or inequality. It defines the model equality/inequality constraint. In FBA, all the linear set of equations derived from the differential mass balances are equality equations. Therefore, all elements of model.sense is set to \u2018=\u2019. For simplicity, the above object can be defined as follows in MATLAB: model.A = sparse(S); model.obj = zeros(1,size(A,1)); model.lb = lb; model.ub = ub; model.rhs = zeros(size(A,2),1); model.vtype = 'C'; model.sense = '='; Finally, running sol=gurobi(model); will generate an output, \u2018sol\u2019, which is a structure object with several fields. The most important fields in the structure object are sol.x, sol.status, and sol.objval, which stores the predicted v vector (the flux vector), whether the obtained solution is optimal (sometimes it might be \u2018 INFEASIBLE \u2019, \u2018 SUB-OPTIMAL \u2019 or \u2018 NUMERIC \u2019. Care should be taken especially for \u2018 SUB-OPTIMAL \u2019 since it also returns a flux vector which is not possible when the status is \u2018 NUMERIC \u2019 or \u2018 INFEASIBLE \u2019) and the value of the objective function, respectively. Under circumstances where no optimal solution could be found by the solver, finding the root cause of the problem should begin by checking out numerical consistencies in the defined system constraints. When this does not solve the problem, getting into more advanced troubleshooting approaches using parameter control methods should follow. More detailed information on Gurobi solver parameter control can be found here . What should guide the choice of a new parameter is taking into consideration the solver\u2019s default parameters and weighing the cost of each change on the accuracy of the results to be obtained.","title":"FBA in MATLAB"},{"location":"fbaMATLAB/#procedure-for-using-gurobi-solver-in-matlab-for-fba","text":"Gurobi solver can used to solve most programming problems. In the linear system we defined above, we seek to solve the following problem: min/max \\sum_{i=0}^n f(v_i), such that S\u00d7v \\leq b, Seq\u00d7v = beq, lb \\leq v \\leq ub. The output of this optimization problem is the vector v, which optimizes the function f. The general implementation steps are as follows: sol=gurobi(model). Here, the object \u2018model\u2019 is a MATLAB structure object with the following main fields: model.A \u2192 An mxn matrix. the S matrix (stoichiometric matrix) must be renamed as model.A and stored as a sparse matrix. Using sparse(S) returns a sparse matrix for the S matrix. model.obj \u2192 An nx1 vector. The objective function vector, f, explained above must be renamed as model.obj. model.lb \u2192 An nx1 vector. The lower bound vector. model.ub \u2192 An nx1 vector. The upper bound vector. model.rhs \u2192 A zero m\u00d71 vector. The right-hand-side vector, b, explained above must be renamed as model.rhs. model.vtype \u2192 An nx1 vector. It is a cell array that can be of \u2018B\u2019, \u2018C\u2019 or \u2018I\u2019 for binary, continuous and integer respectively based on the problem being solved. In FBA, all the unknowns (rates) are continuous. Therefore, all elements of model.vtype is set to \u2018C\u2019. model.sense \u2192 An mx1 vector. It is a cell array that can be of \u2018=\u2019, \u2018<\u2019 or \u2018>\u2019 for equality or inequality. It defines the model equality/inequality constraint. In FBA, all the linear set of equations derived from the differential mass balances are equality equations. Therefore, all elements of model.sense is set to \u2018=\u2019. For simplicity, the above object can be defined as follows in MATLAB: model.A = sparse(S); model.obj = zeros(1,size(A,1)); model.lb = lb; model.ub = ub; model.rhs = zeros(size(A,2),1); model.vtype = 'C'; model.sense = '='; Finally, running sol=gurobi(model); will generate an output, \u2018sol\u2019, which is a structure object with several fields. The most important fields in the structure object are sol.x, sol.status, and sol.objval, which stores the predicted v vector (the flux vector), whether the obtained solution is optimal (sometimes it might be \u2018 INFEASIBLE \u2019, \u2018 SUB-OPTIMAL \u2019 or \u2018 NUMERIC \u2019. Care should be taken especially for \u2018 SUB-OPTIMAL \u2019 since it also returns a flux vector which is not possible when the status is \u2018 NUMERIC \u2019 or \u2018 INFEASIBLE \u2019) and the value of the objective function, respectively. Under circumstances where no optimal solution could be found by the solver, finding the root cause of the problem should begin by checking out numerical consistencies in the defined system constraints. When this does not solve the problem, getting into more advanced troubleshooting approaches using parameter control methods should follow. More detailed information on Gurobi solver parameter control can be found here . What should guide the choice of a new parameter is taking into consideration the solver\u2019s default parameters and weighing the cost of each change on the accuracy of the results to be obtained.","title":"Procedure for using Gurobi solver in MATLAB for FBA"},{"location":"fbaR/","text":"CONTRIBUTORS: Written: Regan ODONGO , Edited: Tunahan \u00c7AKIR Procedure for using Gurobi solver in R for FBA R programming uses different file formats as is explained next. Also, this section will describe only the data acquisition to FBA using Gurobi solver steps. All the other steps should be followed as previously described. In R, data can be loaded and saved as follows: Load the Excel file using stoichMat<- readxl::read_excel(\u2018filename.xlsx\u2019) , assuming the file is named \u2018filename.xlsx\u2019 . NOTE : R is dependent on packages so remember to load this package using library(readxl) before attempting to import the excel file. Next, use saveRDS(stoichMat,file=\u2018stoichMat.RDS\u2019) to save the matrix as a .RDS file object. This .RDS file can be introduced into the working space memory of R using the \u2018readRDS\u2019 function, e.g. readRDS(\u2018stoichMat.RDS) . Note that. RData is an alternative to .RDS . However, .RDS is more suitable for storing single variables like in the current case. Using Gurobi in R First and foremost, Gurobi in R requires installation and loading to the current working memory of two main packages; \u2018gurobi\u2019 and \u2018slam\u2019 as follows: install.packages(\u2018c:/gurobi800/win64/R/gurobi_8.0-0.zip\u2019, repos = NULL) install.packages(\u2018slam\u2019, repos = \u2018https://cloud.r-project.org\u2019) library(gurobi) The general implementation steps are as follows: sol \\to gurobi(model,list()) Here, the object \u2018model\u2019 is an R list object with the following main fields similar to those described for MATLAB : model$A \u2192 An mxn matrix. the S matrix (stoichiometric matrix) must be renamed as model.A and stored as a sparse matrix. Using sparse(S) returns a sparse matrix for the S matrix. model$obj \u2192 An nx1 vector. The objective function vector, f, explained above must be renamed as model.obj. model$lb \u2192 An nx1 vector. The lower bound vector. model$ub \u2192 An nx1 vector. The upper bound vector. model$rhs \u2192 A zero m\u00d71 vector. The right-hand-side vector, b, explained above must be renamed as model.rhs. model$vtype \u2192 An nx1 vector. It is a cell array that can be of \u2018B\u2019, \u2018C\u2019 or \u2018I\u2019 for binary, continuous and integer respectively based on the problem being solved. In FBA, all the unknowns (rates) are continuous. Therefore, all elements of model.vtype is set to \u2018C\u2019. model$sense \u2192 An mx1 vector. It is a cell array that can be of \u2018=\u2019, \u2018<\u2019 or \u2018>\u2019 for equality or inequality. It defines the model equality/inequality constraint. In FBA, all the linear set of equations derived from the differential mass balances are equality equations. Therefore, all elements of model.sense is set to \u2018=\u2019. For simplicity, the above object can be defined as follows in R: model = list() model$A = S model$obj = c(rep(0,ncol(S))) model$lb = lb model$ub = ub model$rhs = c(rep(0,nrow(S))) model$vtype = 'C' model$sense = '=' Further information on how to handle models in using Gurobi solver can be found here . The output \u2018sol\u2019 is similar to the one obtained from MATLAB as described previously.","title":"FBA in R"},{"location":"fvaINTRO/","text":"CONTRIBUTORS: Written: Regan ODONGO , Edited: Tunahan \u00c7AKIR Flux Variability Analysis (FVA) In genome scale metabolic modelling, the set system's objective function can often be achieved through alternative metabolic reactions. For instance, if growth (biomass accumulation) is used as the reaction to be maximized/minimized, there might exist several alternative metabolic flux solutions that can give the same objective value due to biological functional heterogeneity, especially for solutions obtained using linear programming (LP). In such situations, only the objective function solution is unique. Thus, it is ideal to investigate and characterize flux variability of the system i.e., to find the maximum and minimum values of each flux that can achieve the same objective value. This is particularly useful when performing metabolic engineering of cellular system as it highlights important factors to be considered in advance. An illustrated explanation of FVA is provided with our Valino simulation tutorial . Given a COBRA model: model, and the reaction at location X in the model, whose maximum/minimum flux has been determined using LP, FVA can be calculated using the following lines of code in MATLAB with Gurobi solver: model.lb(X)= maximum/minimum value of X; model.ub(X)= maximum/minimum value of X; for i=1:length(model.A(1,:)) model.obj=zeros(length(model.A(1,:)),1); model.obj(i)=1; Vmin=gurobi(model,params); model.obj(i)=-1; Vmax=gurobi(model); FVA(i,:)=([Vmin.x(i) Vmax.x(i)]); end Where, Vmax and Vmin are the maximum and minimum fluxes through each reaction in the model and FVA the matrix holding all the solutions. Reference Mahadevan R., and Schilling C.H., (2003). The effects of alternate optimal solutions in constraint-based genome-scale metabolic models, Metabolic Engineering (Vol. 5, Issue 4, pp. 264-276)","title":"FVA"},{"location":"fvaINTRO/#flux-variability-analysis-fva","text":"In genome scale metabolic modelling, the set system's objective function can often be achieved through alternative metabolic reactions. For instance, if growth (biomass accumulation) is used as the reaction to be maximized/minimized, there might exist several alternative metabolic flux solutions that can give the same objective value due to biological functional heterogeneity, especially for solutions obtained using linear programming (LP). In such situations, only the objective function solution is unique. Thus, it is ideal to investigate and characterize flux variability of the system i.e., to find the maximum and minimum values of each flux that can achieve the same objective value. This is particularly useful when performing metabolic engineering of cellular system as it highlights important factors to be considered in advance. An illustrated explanation of FVA is provided with our Valino simulation tutorial . Given a COBRA model: model, and the reaction at location X in the model, whose maximum/minimum flux has been determined using LP, FVA can be calculated using the following lines of code in MATLAB with Gurobi solver: model.lb(X)= maximum/minimum value of X; model.ub(X)= maximum/minimum value of X; for i=1:length(model.A(1,:)) model.obj=zeros(length(model.A(1,:)),1); model.obj(i)=1; Vmin=gurobi(model,params); model.obj(i)=-1; Vmax=gurobi(model); FVA(i,:)=([Vmin.x(i) Vmax.x(i)]); end Where, Vmax and Vmin are the maximum and minimum fluxes through each reaction in the model and FVA the matrix holding all the solutions. Reference Mahadevan R., and Schilling C.H., (2003). The effects of alternate optimal solutions in constraint-based genome-scale metabolic models, Metabolic Engineering (Vol. 5, Issue 4, pp. 264-276)","title":"Flux Variability Analysis (FVA)"},{"location":"valinoSim/","text":"A Small Scale Metabolic Model of Corynebacterium glutamicum CONTRIBUTORS MATLAB file: Ecehan Abdik , R file: Elif Emanetci , Excel file: \u0130sa Y\u00fcksel , MATLAB Live Editor: Kadir Kocaba\u015f , R Markdown: H. B\u00fc\u015fra L\u00fcleci , Editing: Tunahan \u00c7ak\u0131r 1. About the Model Corynebacterium glutamicum is a bacterium used for industrial production of amino acids. It was initially discovered as a glutamate producer, as the name suggests. Vallino et al. (1993) constructed a small-scale metabolic network to determine basal metabolic flux distribution of C.glutamicum for lysine overproduction using stoichiometric mass balancing [1]. Their metabolic network consists of 34 intracellular metabolic reactions and 37 metabolites. 12 of those metabolites are exchanged with the extracellular environment. The authors collected experimental data to validate the metabolic network by growing the organism in batch fermentation. They broke down the batch fermentation into four separate phases and calculated metabolic fluxes for each phase separately (see Figure 2A of the paper [1]). The mass balance equations were constructed around the 37 intracellular metabolites. They used measured uptake/release rates of 12 extracellular metabolites to calculate metabolic flux distributions by a least-square approach since their system was overdetermined. The extracellular metabolites are glucose, oxygen, ammonium, CO2, biomass, acetate, alanine, lactate, lysine, pyruvate, trehalose and valine. We rearranged their metabolic network as COBRA compatible .mat file and sbml file, both of which can be used to apply Flux Balance Analysis (FBA). The model is also available in stoichiometric matrix format and in reaction list format in an Excel file. The rearranged metabolic network accessible via those files has 34 intracellular metabolic reactions and 14 exchange reactions. Below, we run the model for phase I of the batch fermentation. The metabolic fluxes predicted by the authors for this phase are given in Figure 4 of their paper [1]. The model has 48 unknowns (number of reactions) and 42 independent equations (rank of the stoichiometric matrix). Therefore, the degrees of freedom (dof) of the model is 6. In oppose to the overdetermined solution strategy in the original paper, here we aimed to solve the system using FBA, which requires an underdetermined system (dof > 0). We wanted to predict values as close as possible to Figure 4 of the paper at the same time. Therefore, we used five measured flux rates (exchange reactions of ammonium, glucose, lactate, oxygen and trehalose) as constraints in the simulations below, making dof value 1. 2. Reading or Loading the model We provide two alternatives to import the metabolic model to MATLAB. The first one (denoted as case 1 below) is reading the model from the sbml file by using readCbModel of COBRA Toolbox. The second one (denoted as case 2 below) is loading the provided .mat file to MATLAB. prefer=input(['Would you prefer to read sbml formatted model or load mat formatted model? ' ... '(enter 1 for reading or 2 for load): ']); switch prefer case 1 model=readCbModel('Vallino_COBRAtc.xml'); case 2 load('Vallino.mat') end 3. Exploring metabolic model There are three main fields in the metabolic models. a) Stoichiometric Matrix (S Matrix) = It is a two dimensional numeric matrix that represents coefficients in metabolic reactions. Columns and rows represent reactions (unknowns) and metabolites (equations) respectively (See FBA Primer page for details). b) mets = It is the list of metabolites included in the model reactions. Here, metabolites are usually represented by abbreviations. To display the first 5 metabolites in the model (i.e.the metabolites corresponding to the first 5 rows of S matrix): model.mets(1:5) c) rxns = It is the list of all reactions in the model. The names/IDs of reactions are stored here. To display the first 5 reactions in the model (i.e.the reactions corresponding to the first 5 columns of S matrix): model.rxns(1:5) 4. Formatting for Gurobi optimization solver There are a couple of optimization solvers that can be used to predict the flux distributions for underdetermined metabolic models. The most common ones are glpk, Gurobi and IBM CPLEX. Among those, glpk is a free solver, and free academic license is available for Gurobi and CPLEX. Gurobi requires a specific model structure that can be created by using the information in the .mat formatted or .sbml derived metabolic model. Structure of Gurobi model: A = The stoichiometric matrix, which holds all the equations in matrix format, must be named as A. The matrix is conventionally named as S in metabolic modeling literature. lb = The lower bound vector of the reactions (minimum allowable rates for reactions) must be named as lb. ub = The upper bound vector of the reactions (maximum allowable rates for reactions) must be named as ub. rhs = The right hand side vector in the mass-balance-based FBA equation (S.v = b) must be named as rhs. It is conventionally named as b in metabolic modeling literature (Figure 2). obj= The vector that defines objective function coefficients must be named as obj. Negative coefficient indicates maximization while positive coefficient indicates minimization. It is conventionally named as f in metabolic modeling literature. sense= The cell array that shows whether an equation defines equality or inequality. Since all mass-balance based equations in FBA are equality equations, all elements of sense array must be \"=\". vtype= The cell array that defines whether an unknown is continuous, binary or integer. Since our unknowns (reaction rates) are continuous, all elements of vtype array must be \"C\". Gurobimodel.A = [model.S]; % Stochiomatrix format for gurobi showen as A instead of S Gurobimodel.A = sparse(Gurobimodel.A); % Gurobi requires A as a sparse matrix Gurobimodel.lb = model.lb; Gurobimodel.ub = model.ub; Gurobimodel.rhs= zeros(length(Gurobimodel.A(:,1)),1); Gurobimodel.obj= zeros(length(Gurobimodel.A(1,:)),1); % objective function Gurobimodel.sense = ['=']; Gurobimodel.vtype = 'C' ; Figure 2 : S matrix 5. Defining Constraints for the Experimental Condition Phase I of the batch fermentation will be simulated here. The experimentally measured secretion rates were taken from [2]. Although 12 exchange rates were measured by the authors, we use 5 of them here, which corresponds to an underdetermined system with degrees of freedom 1. The rates of corresponding exchange reactions are fixed to the experimental values by setting their upper and lower bounds to the same value. Gurobimodel.lb(35) = 100; Gurobimodel.ub(35)=100; % glucose uptake Gurobimodel.lb(36) = 68.3; Gurobimodel.ub(36)=68.3; % NH3 uptake Gurobimodel.lb(37) = 231; Gurobimodel.ub(37)=231; % O2 uptake Gurobimodel.lb(42) = 2.5; Gurobimodel.ub(42)= 2.5;% trehalose release Gurobimodel.lb(43) = 0.3; Gurobimodel.ub(43)= 0.3; % lactate release 6. Defining the Objective Function: Maximization of Growth The biomass reaction is 33th reaction in the model. To maximize growth, 33th index of obj vector will be defined as -1, with all other indices set to zero. The obj vector was already initialized above (Section 4) as a zero vector. Gurobimodel.obj(33) = -1; 7. Running the Optimization and Exploring the Results All necessary rearrangements were made in the previous steps (eg. defining the constraints and the objective function). Now, the function \"gurobi\" will be used to predict a flux distribution that corresponds to maximum growth rate for the defined constraints. phaseI = gurobi(Gurobimodel); Gurobi generates an output in structure format, with a couple of outputs. The most relevant outputs are objval and x. objval = reports the optimum value of the objective function. In this case, it will print the maximum growth rate for the defined constraints. To display the objective value: phaseI.objval x = reports the predicted flux vector. To display reaction rates (fluxes) of the first 5 reactions: phaseI.x(1:5) 8. Flux Variability Analysis (FVA) The constraint-based modelling approach is a combination of mathematical techniques that optimize hundreds of mass balance derived equations written based on reactions inside organism of interest. In constraint-based metabolic models, alternate optima can be an issue in interpreting the results of FBA since there might be multiple flux distributions that result in the same value for the objective function (Figure 3). FVA method determines the maximum and minimum flux value of all reactions can take for the same objective value. In this section, firstly, upper and lower bound of the biomass reaction is set to the previously found maximum biomass production rate (in the Maximization of biomass section). Secondly, the maximum and minimum flux values of all reactions can take are determined by changing the objective function inside for loop. Gurobimodel.lb(33)=phaseI.x(33); Gurobimodel.ub(33)=phaseI.x(33); for i=1:length(Gurobimodel.A(1,:)) Gurobimodel.obj=zeros(length(Gurobimodel.A(1,:)),1); Gurobimodel.obj(i)=1; Vmin=gurobi(Gurobimodel,params); Gurobimodel.obj(i)=-1; Vmax=gurobi(Gurobimodel); FVA_I(i,:)=([Vmin.x(i) Vmax.x(i)]); end Figure 3 : Representation of flux variability on a toy model. The red lines with arrow and R1,R2,R3,R4,R5 and R6 indicate irreversible reactions and reaction names respectively. The circles represent metabolites. Flux variability will be an issue if maximization of the red metabolite were chosen as objective function since it can be produced through R1, R2 and R6 as well as R3, R4 and R5 reaction chains. IMPORTANT NOTE : You can access a MATLAB LiveScipt file of this tutorial from GitHub by following this link References Vallino, J. J., & Stephanopoulos, G. (1993). Metabolic flux distributions in Corynebacterium glutamicum during growth and lysine overproduction. Biotechnology and Bioengineering, 41(6), 633-646.","title":"valinoSim"},{"location":"valinoSim/#a-small-scale-metabolic-model-of-corynebacterium-glutamicum","text":"CONTRIBUTORS MATLAB file: Ecehan Abdik , R file: Elif Emanetci , Excel file: \u0130sa Y\u00fcksel , MATLAB Live Editor: Kadir Kocaba\u015f , R Markdown: H. B\u00fc\u015fra L\u00fcleci , Editing: Tunahan \u00c7ak\u0131r 1. About the Model Corynebacterium glutamicum is a bacterium used for industrial production of amino acids. It was initially discovered as a glutamate producer, as the name suggests. Vallino et al. (1993) constructed a small-scale metabolic network to determine basal metabolic flux distribution of C.glutamicum for lysine overproduction using stoichiometric mass balancing [1]. Their metabolic network consists of 34 intracellular metabolic reactions and 37 metabolites. 12 of those metabolites are exchanged with the extracellular environment. The authors collected experimental data to validate the metabolic network by growing the organism in batch fermentation. They broke down the batch fermentation into four separate phases and calculated metabolic fluxes for each phase separately (see Figure 2A of the paper [1]). The mass balance equations were constructed around the 37 intracellular metabolites. They used measured uptake/release rates of 12 extracellular metabolites to calculate metabolic flux distributions by a least-square approach since their system was overdetermined. The extracellular metabolites are glucose, oxygen, ammonium, CO2, biomass, acetate, alanine, lactate, lysine, pyruvate, trehalose and valine. We rearranged their metabolic network as COBRA compatible .mat file and sbml file, both of which can be used to apply Flux Balance Analysis (FBA). The model is also available in stoichiometric matrix format and in reaction list format in an Excel file. The rearranged metabolic network accessible via those files has 34 intracellular metabolic reactions and 14 exchange reactions. Below, we run the model for phase I of the batch fermentation. The metabolic fluxes predicted by the authors for this phase are given in Figure 4 of their paper [1]. The model has 48 unknowns (number of reactions) and 42 independent equations (rank of the stoichiometric matrix). Therefore, the degrees of freedom (dof) of the model is 6. In oppose to the overdetermined solution strategy in the original paper, here we aimed to solve the system using FBA, which requires an underdetermined system (dof > 0). We wanted to predict values as close as possible to Figure 4 of the paper at the same time. Therefore, we used five measured flux rates (exchange reactions of ammonium, glucose, lactate, oxygen and trehalose) as constraints in the simulations below, making dof value 1. 2. Reading or Loading the model We provide two alternatives to import the metabolic model to MATLAB. The first one (denoted as case 1 below) is reading the model from the sbml file by using readCbModel of COBRA Toolbox. The second one (denoted as case 2 below) is loading the provided .mat file to MATLAB. prefer=input(['Would you prefer to read sbml formatted model or load mat formatted model? ' ... '(enter 1 for reading or 2 for load): ']); switch prefer case 1 model=readCbModel('Vallino_COBRAtc.xml'); case 2 load('Vallino.mat') end 3. Exploring metabolic model There are three main fields in the metabolic models. a) Stoichiometric Matrix (S Matrix) = It is a two dimensional numeric matrix that represents coefficients in metabolic reactions. Columns and rows represent reactions (unknowns) and metabolites (equations) respectively (See FBA Primer page for details). b) mets = It is the list of metabolites included in the model reactions. Here, metabolites are usually represented by abbreviations. To display the first 5 metabolites in the model (i.e.the metabolites corresponding to the first 5 rows of S matrix): model.mets(1:5) c) rxns = It is the list of all reactions in the model. The names/IDs of reactions are stored here. To display the first 5 reactions in the model (i.e.the reactions corresponding to the first 5 columns of S matrix): model.rxns(1:5) 4. Formatting for Gurobi optimization solver There are a couple of optimization solvers that can be used to predict the flux distributions for underdetermined metabolic models. The most common ones are glpk, Gurobi and IBM CPLEX. Among those, glpk is a free solver, and free academic license is available for Gurobi and CPLEX. Gurobi requires a specific model structure that can be created by using the information in the .mat formatted or .sbml derived metabolic model. Structure of Gurobi model: A = The stoichiometric matrix, which holds all the equations in matrix format, must be named as A. The matrix is conventionally named as S in metabolic modeling literature. lb = The lower bound vector of the reactions (minimum allowable rates for reactions) must be named as lb. ub = The upper bound vector of the reactions (maximum allowable rates for reactions) must be named as ub. rhs = The right hand side vector in the mass-balance-based FBA equation (S.v = b) must be named as rhs. It is conventionally named as b in metabolic modeling literature (Figure 2). obj= The vector that defines objective function coefficients must be named as obj. Negative coefficient indicates maximization while positive coefficient indicates minimization. It is conventionally named as f in metabolic modeling literature. sense= The cell array that shows whether an equation defines equality or inequality. Since all mass-balance based equations in FBA are equality equations, all elements of sense array must be \"=\". vtype= The cell array that defines whether an unknown is continuous, binary or integer. Since our unknowns (reaction rates) are continuous, all elements of vtype array must be \"C\". Gurobimodel.A = [model.S]; % Stochiomatrix format for gurobi showen as A instead of S Gurobimodel.A = sparse(Gurobimodel.A); % Gurobi requires A as a sparse matrix Gurobimodel.lb = model.lb; Gurobimodel.ub = model.ub; Gurobimodel.rhs= zeros(length(Gurobimodel.A(:,1)),1); Gurobimodel.obj= zeros(length(Gurobimodel.A(1,:)),1); % objective function Gurobimodel.sense = ['=']; Gurobimodel.vtype = 'C' ; Figure 2 : S matrix 5. Defining Constraints for the Experimental Condition Phase I of the batch fermentation will be simulated here. The experimentally measured secretion rates were taken from [2]. Although 12 exchange rates were measured by the authors, we use 5 of them here, which corresponds to an underdetermined system with degrees of freedom 1. The rates of corresponding exchange reactions are fixed to the experimental values by setting their upper and lower bounds to the same value. Gurobimodel.lb(35) = 100; Gurobimodel.ub(35)=100; % glucose uptake Gurobimodel.lb(36) = 68.3; Gurobimodel.ub(36)=68.3; % NH3 uptake Gurobimodel.lb(37) = 231; Gurobimodel.ub(37)=231; % O2 uptake Gurobimodel.lb(42) = 2.5; Gurobimodel.ub(42)= 2.5;% trehalose release Gurobimodel.lb(43) = 0.3; Gurobimodel.ub(43)= 0.3; % lactate release 6. Defining the Objective Function: Maximization of Growth The biomass reaction is 33th reaction in the model. To maximize growth, 33th index of obj vector will be defined as -1, with all other indices set to zero. The obj vector was already initialized above (Section 4) as a zero vector. Gurobimodel.obj(33) = -1; 7. Running the Optimization and Exploring the Results All necessary rearrangements were made in the previous steps (eg. defining the constraints and the objective function). Now, the function \"gurobi\" will be used to predict a flux distribution that corresponds to maximum growth rate for the defined constraints. phaseI = gurobi(Gurobimodel); Gurobi generates an output in structure format, with a couple of outputs. The most relevant outputs are objval and x. objval = reports the optimum value of the objective function. In this case, it will print the maximum growth rate for the defined constraints. To display the objective value: phaseI.objval x = reports the predicted flux vector. To display reaction rates (fluxes) of the first 5 reactions: phaseI.x(1:5) 8. Flux Variability Analysis (FVA) The constraint-based modelling approach is a combination of mathematical techniques that optimize hundreds of mass balance derived equations written based on reactions inside organism of interest. In constraint-based metabolic models, alternate optima can be an issue in interpreting the results of FBA since there might be multiple flux distributions that result in the same value for the objective function (Figure 3). FVA method determines the maximum and minimum flux value of all reactions can take for the same objective value. In this section, firstly, upper and lower bound of the biomass reaction is set to the previously found maximum biomass production rate (in the Maximization of biomass section). Secondly, the maximum and minimum flux values of all reactions can take are determined by changing the objective function inside for loop. Gurobimodel.lb(33)=phaseI.x(33); Gurobimodel.ub(33)=phaseI.x(33); for i=1:length(Gurobimodel.A(1,:)) Gurobimodel.obj=zeros(length(Gurobimodel.A(1,:)),1); Gurobimodel.obj(i)=1; Vmin=gurobi(Gurobimodel,params); Gurobimodel.obj(i)=-1; Vmax=gurobi(Gurobimodel); FVA_I(i,:)=([Vmin.x(i) Vmax.x(i)]); end Figure 3 : Representation of flux variability on a toy model. The red lines with arrow and R1,R2,R3,R4,R5 and R6 indicate irreversible reactions and reaction names respectively. The circles represent metabolites. Flux variability will be an issue if maximization of the red metabolite were chosen as objective function since it can be produced through R1, R2 and R6 as well as R3, R4 and R5 reaction chains. IMPORTANT NOTE : You can access a MATLAB LiveScipt file of this tutorial from GitHub by following this link References Vallino, J. J., & Stephanopoulos, G. (1993). Metabolic flux distributions in Corynebacterium glutamicum during growth and lysine overproduction. Biotechnology and Bioengineering, 41(6), 633-646.","title":"A Small Scale Metabolic Model of Corynebacterium glutamicum"}]}